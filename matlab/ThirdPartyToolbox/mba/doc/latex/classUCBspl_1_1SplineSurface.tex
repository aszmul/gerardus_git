\section{UCBspl::SplineSurface Class Reference}
\label{classUCBspl_1_1SplineSurface}\index{UCBspl::SplineSurface@{UCBspl::SplineSurface}}


Represents a uniform cubic B-\/spline surface.  




{\ttfamily \#include $<$UCBsplineSurface.h$>$}

\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
{\bf SplineSurface} ()
\item 
{\bf SplineSurface} (boost::shared\_\-ptr$<$ {\bf GenMatrixType} $>$ PHI, double umin, double vmin, double umax, double vmax)
\item 
{\bf SplineSurface} (const {\bf SplineSurface} \&surf)
\item 
void {\bf init} (boost::shared\_\-ptr$<$ {\bf GenMatrixType} $>$ PHI, double umin, double vmin, double umax, double vmax)
\item 
void {\bf getDomain} (double \&umin, double \&vmin, double \&umax, double \&vmax) const 
\item 
double {\bfseries umin} () const \label{classUCBspl_1_1SplineSurface_aecebc819dbb3a3b976e772c201e248d8}

\item 
double {\bfseries vmin} () const \label{classUCBspl_1_1SplineSurface_a85bc9e38c850d7f53166b497954eb01c}

\item 
double {\bfseries umax} () const \label{classUCBspl_1_1SplineSurface_a9aee502db1a9ecb40ec02ad03ce7c102}

\item 
double {\bfseries vmax} () const \label{classUCBspl_1_1SplineSurface_a5aeae806ea8123d074131e67d02f6c56}

\item 
double {\bf f} (double u, double v) const 
\item 
double {\bf f} (int i, int j) const 
\item 
void {\bf normalVector} (double u, double v, double \&gx, double \&gy, double \&gz) const 
\item 
void {\bf normalVector} (int i, int j, double \&gx, double \&gy, double \&gz) const 
\item 
void {\bfseries derivatives} (double u, double v, double \&dx, double \&dy) const \label{classUCBspl_1_1SplineSurface_a54c8f88d0c3ec19386312828c456b93b}

\item 
void {\bfseries secondDerivatives} (double u, double v, double \&ddx, double \&ddy, double \&dxdy) const \label{classUCBspl_1_1SplineSurface_a01bfc54bc7c1d03768731e3449bc3724}

\item 
void {\bfseries curvatures} (double u, double v, double \&profC, double \&planC) const \label{classUCBspl_1_1SplineSurface_a299a725604f49c805c1c65ec646a2969}

\item 
void {\bf eval} (double u, double v, double \&z, double \&gx, double \&gy, double \&gz) const 
\item 
void {\bf eval} (int i, int j, double \&z, double \&gx, double \&gy, double \&gz) const 
\item 
const boost::shared\_\-ptr$<$ {\bf GenMatrixType} $>$ {\bf getCoefficients} () const 
\item 
void {\bf getIndexDomain} (int \&m, int \&n) const 
\item 
void {\bf refineCoeffs} ()
\item 
bool {\bf restrictCoeffs} ()
\end{DoxyCompactItemize}


\subsection{Detailed Description}
Represents a uniform cubic B-\/spline surface. \doxyref{SplineSurface}{p.}{classUCBspl_1_1SplineSurface} -\/ A uniform cubic B-\/spline surface compatible with that produced by the SINTEF \doxyref{MBA}{p.}{classMBA} library. \begin{DoxyAuthor}{Author}
Øyvind Hjelle $<${\tt Oyvind.Hjelle@math.sintef.no}$>$ 
\end{DoxyAuthor}


\subsection{Constructor \& Destructor Documentation}
\index{UCBspl::SplineSurface@{UCBspl::SplineSurface}!SplineSurface@{SplineSurface}}
\index{SplineSurface@{SplineSurface}!UCBspl::SplineSurface@{UCBspl::SplineSurface}}
\subsubsection[{SplineSurface}]{\setlength{\rightskip}{0pt plus 5cm}UCBspl::SplineSurface::SplineSurface (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  [inline]}}\label{classUCBspl_1_1SplineSurface_aa5af2fe65a83dd1192b2c7dc814ca476}
Default constructor makes the domain over the unit square, but coefficient matrix is not allocated. \index{UCBspl::SplineSurface@{UCBspl::SplineSurface}!SplineSurface@{SplineSurface}}
\index{SplineSurface@{SplineSurface}!UCBspl::SplineSurface@{UCBspl::SplineSurface}}
\subsubsection[{SplineSurface}]{\setlength{\rightskip}{0pt plus 5cm}SplineSurface::SplineSurface (
\begin{DoxyParamCaption}
\item[{boost::shared\_\-ptr$<$ {\bf GenMatrixType} $>$}]{ PHI, }
\item[{double}]{ umin, }
\item[{double}]{ vmin, }
\item[{double}]{ umax, }
\item[{double}]{ vmax}
\end{DoxyParamCaption}
)}\label{classUCBspl_1_1SplineSurface_a4874e5c26ff5be63f19b606b062fb544}
Constructor with (standard) shared pointers to the uniform tensor product grid, and the domain. \index{UCBspl::SplineSurface@{UCBspl::SplineSurface}!SplineSurface@{SplineSurface}}
\index{SplineSurface@{SplineSurface}!UCBspl::SplineSurface@{UCBspl::SplineSurface}}
\subsubsection[{SplineSurface}]{\setlength{\rightskip}{0pt plus 5cm}SplineSurface::SplineSurface (
\begin{DoxyParamCaption}
\item[{const {\bf SplineSurface} \&}]{ surf}
\end{DoxyParamCaption}
)}\label{classUCBspl_1_1SplineSurface_adff77b78f9dd41ac6e9a1dd46eebf892}
Copy constructor 

\subsection{Member Function Documentation}
\index{UCBspl::SplineSurface@{UCBspl::SplineSurface}!eval@{eval}}
\index{eval@{eval}!UCBspl::SplineSurface@{UCBspl::SplineSurface}}
\subsubsection[{eval}]{\setlength{\rightskip}{0pt plus 5cm}void SplineSurface::eval (
\begin{DoxyParamCaption}
\item[{double}]{ u, }
\item[{double}]{ v, }
\item[{double \&}]{ z, }
\item[{double \&}]{ gx, }
\item[{double \&}]{ gy, }
\item[{double \&}]{ gz}
\end{DoxyParamCaption}
) const}\label{classUCBspl_1_1SplineSurface_a453fe9d96a026d9497f20c7ed5aa49c7}
Evaluates both function value and normalized normal vector. (u,v) must be inside the domain, see getDomain. This is faster than calling the functions above separately, e.g., when making triangle strips for visualization. \index{UCBspl::SplineSurface@{UCBspl::SplineSurface}!eval@{eval}}
\index{eval@{eval}!UCBspl::SplineSurface@{UCBspl::SplineSurface}}
\subsubsection[{eval}]{\setlength{\rightskip}{0pt plus 5cm}void SplineSurface::eval (
\begin{DoxyParamCaption}
\item[{int}]{ i, }
\item[{int}]{ j, }
\item[{double \&}]{ z, }
\item[{double \&}]{ gx, }
\item[{double \&}]{ gy, }
\item[{double \&}]{ gz}
\end{DoxyParamCaption}
) const}\label{classUCBspl_1_1SplineSurface_a89d1819ab746b4bd955dd9a96d2fd89d}
Same as eval(double u, double v,...), in a grid point. See also documentation of UCBsplineSurface::f (int i, int j). 

References f(), and normalVector().

\index{UCBspl::SplineSurface@{UCBspl::SplineSurface}!f@{f}}
\index{f@{f}!UCBspl::SplineSurface@{UCBspl::SplineSurface}}
\subsubsection[{f}]{\setlength{\rightskip}{0pt plus 5cm}double SplineSurface::f (
\begin{DoxyParamCaption}
\item[{double}]{ u, }
\item[{double}]{ v}
\end{DoxyParamCaption}
) const}\label{classUCBspl_1_1SplineSurface_ade147b9806497718ed72c4283848e509}
Evaluates the functional value of the surface in position (u,v) (u,v) must be inside the domain 

Referenced by eval().

\index{UCBspl::SplineSurface@{UCBspl::SplineSurface}!f@{f}}
\index{f@{f}!UCBspl::SplineSurface@{UCBspl::SplineSurface}}
\subsubsection[{f}]{\setlength{\rightskip}{0pt plus 5cm}double SplineSurface::f (
\begin{DoxyParamCaption}
\item[{int}]{ i, }
\item[{int}]{ j}
\end{DoxyParamCaption}
) const}\label{classUCBspl_1_1SplineSurface_a8fd6d94b22e0a67cb922c335726fddfe}
Evaluates the functional value of the surface in position (i,j), where (i,j) is an index in the spline coefficient matrix. (i,j) must be inside the domain of the index values: 0 $<$= i $<$= m and 0 $<$= j $<$= n, where m\_\- and n\_\- are retrieved by the function getIndexDomain This is much faster than f(u,v) since pre-\/evaluate bases are used. \index{UCBspl::SplineSurface@{UCBspl::SplineSurface}!getCoefficients@{getCoefficients}}
\index{getCoefficients@{getCoefficients}!UCBspl::SplineSurface@{UCBspl::SplineSurface}}
\subsubsection[{getCoefficients}]{\setlength{\rightskip}{0pt plus 5cm}const boost::shared\_\-ptr$<${\bf GenMatrixType}$>$ UCBspl::SplineSurface::getCoefficients (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily  [inline]}}\label{classUCBspl_1_1SplineSurface_afcf8c5c865048a9bb5613653098b278b}
Get the coefficient grid of the tensor product spline surface. 

Referenced by MBA::init().

\index{UCBspl::SplineSurface@{UCBspl::SplineSurface}!getDomain@{getDomain}}
\index{getDomain@{getDomain}!UCBspl::SplineSurface@{UCBspl::SplineSurface}}
\subsubsection[{getDomain}]{\setlength{\rightskip}{0pt plus 5cm}void UCBspl::SplineSurface::getDomain (
\begin{DoxyParamCaption}
\item[{double \&}]{ umin, }
\item[{double \&}]{ vmin, }
\item[{double \&}]{ umax, }
\item[{double \&}]{ vmax}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily  [inline]}}\label{classUCBspl_1_1SplineSurface_a4c705a8313d13b6eb58023f4b7ba1aa9}
The domain over which the spline surface is defined. \index{UCBspl::SplineSurface@{UCBspl::SplineSurface}!getIndexDomain@{getIndexDomain}}
\index{getIndexDomain@{getIndexDomain}!UCBspl::SplineSurface@{UCBspl::SplineSurface}}
\subsubsection[{getIndexDomain}]{\setlength{\rightskip}{0pt plus 5cm}void UCBspl::SplineSurface::getIndexDomain (
\begin{DoxyParamCaption}
\item[{int \&}]{ m, }
\item[{int \&}]{ n}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily  [inline]}}\label{classUCBspl_1_1SplineSurface_af5f21fbeb68850dba610b94d182cba04}
Index domain of spline coefficient matrix. The surface can also be evaluated by f(i,j) and other functions with 0 $<$= i $<$= m and 0 $<$= j $<$= n. Note that the size of the tensor product grid (in the C2 case) is [(m+3) x (n+3)] \index{UCBspl::SplineSurface@{UCBspl::SplineSurface}!init@{init}}
\index{init@{init}!UCBspl::SplineSurface@{UCBspl::SplineSurface}}
\subsubsection[{init}]{\setlength{\rightskip}{0pt plus 5cm}void SplineSurface::init (
\begin{DoxyParamCaption}
\item[{boost::shared\_\-ptr$<$ {\bf GenMatrixType} $>$}]{ PHI, }
\item[{double}]{ umin, }
\item[{double}]{ vmin, }
\item[{double}]{ umax, }
\item[{double}]{ vmax}
\end{DoxyParamCaption}
)}\label{classUCBspl_1_1SplineSurface_af66b3571169bdecc85fcdc96774f0c4d}
Initialization similar to constructor \index{UCBspl::SplineSurface@{UCBspl::SplineSurface}!normalVector@{normalVector}}
\index{normalVector@{normalVector}!UCBspl::SplineSurface@{UCBspl::SplineSurface}}
\subsubsection[{normalVector}]{\setlength{\rightskip}{0pt plus 5cm}void SplineSurface::normalVector (
\begin{DoxyParamCaption}
\item[{double}]{ u, }
\item[{double}]{ v, }
\item[{double \&}]{ gx, }
\item[{double \&}]{ gy, }
\item[{double \&}]{ gz}
\end{DoxyParamCaption}
) const}\label{classUCBspl_1_1SplineSurface_a9ffc9f98470bebfd180d001e46154213}
Evaluates the normal vector (normalized with length=1) in position in position (u,v). (u,v) must be inside the domain, see getDomain 

Referenced by eval().

\index{UCBspl::SplineSurface@{UCBspl::SplineSurface}!normalVector@{normalVector}}
\index{normalVector@{normalVector}!UCBspl::SplineSurface@{UCBspl::SplineSurface}}
\subsubsection[{normalVector}]{\setlength{\rightskip}{0pt plus 5cm}void SplineSurface::normalVector (
\begin{DoxyParamCaption}
\item[{int}]{ i, }
\item[{int}]{ j, }
\item[{double \&}]{ gx, }
\item[{double \&}]{ gy, }
\item[{double \&}]{ gz}
\end{DoxyParamCaption}
) const}\label{classUCBspl_1_1SplineSurface_a8c309e5e225a7e0c78dadefbc8dab9ec}
Same as gradf(double u, double v,...), in a grid point. See also documentation of f(int i, int j). \index{UCBspl::SplineSurface@{UCBspl::SplineSurface}!refineCoeffs@{refineCoeffs}}
\index{refineCoeffs@{refineCoeffs}!UCBspl::SplineSurface@{UCBspl::SplineSurface}}
\subsubsection[{refineCoeffs}]{\setlength{\rightskip}{0pt plus 5cm}void SplineSurface::refineCoeffs (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\label{classUCBspl_1_1SplineSurface_ad4e50559247de53a2d4f90c10e94455d}
Refine spline surface to the next finer dyadic level. That is, make the tensor product grid twice as dense inside the active domain. Only the mathematical representation of the spline surface is changed, and not the geometry. (Simlar to the Oslo Algorithm.) \index{UCBspl::SplineSurface@{UCBspl::SplineSurface}!restrictCoeffs@{restrictCoeffs}}
\index{restrictCoeffs@{restrictCoeffs}!UCBspl::SplineSurface@{UCBspl::SplineSurface}}
\subsubsection[{restrictCoeffs}]{\setlength{\rightskip}{0pt plus 5cm}bool SplineSurface::restrictCoeffs (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\label{classUCBspl_1_1SplineSurface_a149813a10742e7ce80ee3cc5d544876e}
Restrict the spline surface to the next coarser dyadic level. That is, make the tensor product grid twice as coarse inside the active domain. Both the mathematical representation and the geometry of the spline surface is changed. The effect is that the spline surfaces looks smoother. This operator has the so-\/called variational property with respect to the refinement operator above.

\begin{DoxyNote}{Note}
Restriction can only be done if the modulo of (noX-\/3)/2 and (noY-\/3)/2 are both zero. Here noX and noY is the size of the coefficient matrix.
\end{DoxyNote}

\begin{DoxyRetVals}{Return values}
\item[{\em bool}]{\ttfamily false} if the coefficient grid does not meet the constraints above \end{DoxyRetVals}


The documentation for this class was generated from the following files:\begin{DoxyCompactItemize}
\item 
UCBsplineSurface.h\item 
UCBsplineSurface.cpp\end{DoxyCompactItemize}
